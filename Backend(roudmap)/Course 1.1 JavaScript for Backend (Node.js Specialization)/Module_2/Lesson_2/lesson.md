## 🟦 الوحدة 2: البرمجة غير المتزامنة في جافاسكريبت (Asynchronous JavaScript)

### 📘 الدرس 2: كيف يعمل JavaScript؟ Event Loop، Call Stack، Execution Context

#### 🧠 **ماذا ستتعلم؟**
* كيف تنفذ جافاسكريبت الكود داخل المتصفح أو Node.js.
* مفهوم **Call Stack** ونموذج التنفيذ.
* كيف يعمل **Event Loop** لتنفيذ الكود غير المتزامن.
* الفرق بين المهام المتزامنة وغير المتزامنة (Synchronous vs Asynchronous).

***

### 1. كيف يتم تنفيذ كود جافاسكريبت؟

جافاسكريبت لغة **وحيدة الخيط (single-threaded)**.
👉 يعني أنها تنفذ سطرًا واحدًا في كل لحظة من الزمن، عبر **Call Stack**.

#### 📦 Call Stack

هو المكان الذي تُضاف فيه الدوال عند تنفيذها، وتُزال عند الانتهاء.

> 🔍 **مثال:**
> ```javascript
> function a() {
>   b();
> }
> 
> function b() {
>   console.log("مرحبا");
> }
> 
> a();
> ```

> 🧱 **تسلسل التنفيذ:**
> 1.  يبدأ `a()` ← تُضاف إلى Call Stack.
> 2.  `a()` تستدعي `b()` ← تُضاف إلى Call Stack.
> 3.  `b()` تنفذ ← تطبع ← تُزال.
> 4.  `a()` تنتهي ← تُزال.

***

### 2. ما هو Execution Context؟

كل دالة تُنفذ داخل **سياق تنفيذ (Execution Context)**.
يشمل:
* المتغيرات
* القيم المُمررة
* الكائن `this`

> 👓 **أنواع السياقات:**
> * **Global Context**: السياق الرئيسي.
> * **Function Context**: لكل دالة يتم إنشاؤه عند استدعائها.
> * **Eval Context** (نادر الاستخدام).

***

### 3. Event Loop – الحلقة الحدثية

عندما يكون هناك عمليات **غير متزامنة** (مثل `setTimeout` أو `fetch`)، لا تدخل مباشرة إلى Call Stack، بل يتم إرسالها إلى **Web APIs** (في المتصفح) أو APIs داخل Node.

بعد انتهاء العملية، يتم وضع الدالة المرتبطة بها في **Callback Queue**.

🔄 **Event Loop** هو حلقة مستمرة تفحص:
* هل Call Stack فارغة؟
* إذا نعم ← تُدخل دالة من الـ Callback Queue إلى Call Stack.

> 🔁 **خطوات التنفيذ (تبسيط):**
> 1.  Call Stack ينفذ كل الكود المتزامن.
> 2.  العمليات غير المتزامنة تُمرر لـ Web APIs.
> 3.  عند الانتهاء، تدخل الدالة في **Callback Queue**.
> 4.  Event Loop ينقلها إلى Call Stack عندما يكون فارغًا.

***

### 4. مثال واقعي

```javascript
console.log("أ");
setTimeout(() => console.log("ب"), 0);
console.log("ج");
```

> 🔎 **النتيجة:**
>
> أ
>
> ج
>
> ب
>
> ❓ **لماذا؟** لأن `setTimeout` ينتظر في Callback Queue ← بينما Call Stack يُكمل أولًا.

***
