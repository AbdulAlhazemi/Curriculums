## 🟩 الوحدة 3: أساسيات Node.js

### 📘 الدرس 2: شرح حلقة الحدث (Event Loop) في Node.js

#### 🧠 **ماذا ستتعلم؟**
* كيف تدير Node.js العمليات غير المتزامنة داخليًا.
* كيف تعمل حلقة الحدث (Event Loop).
* العلاقة بين الـ Call Stack، Callback Queue، و APIs في Node.js.
* أهمية هذا النموذج في بناء تطبيقات عالية الأداء.

***

### 1. لماذا Event Loop مهمة في Node.js؟

Node.js تعمل على **خيط واحد (Single Thread)**، لكنها تستطيع التعامل مع آلاف الطلبات دون توقف.

> 🔍 **كيف؟** باستخدام **حلقة الحدث (Event Loop)** التي تدير المهام بطريقة ذكية.

***

### 2. مكونات نظام التنفيذ في Node.js

* **Call Stack**: ينفذ الكود المتزامن.
* **Node APIs / LibUV**: تدير المهام غير المتزامنة (مثل `fs`, `setTimeout`، إلخ).
* **Callback Queue**: ينتظر فيها الكود غير المتزامن ليُعاد تنفيذه.
* **Event Loop**: الحلقة التي تربط بين كل ما سبق.

***

### 3. كيف تعمل Event Loop؟

🌀 **خطوات التنفيذ:**

1.  تنفيذ الكود المتزامن في **Call Stack**.
2.  إرسال العمليات غير المتزامنة (قراءة ملف، اتصال API…) إلى **Node APIs**.
3.  بعد انتهاء المهمة، يُرسل رد الفعل (callback) إلى **Callback Queue**.
4.  **Event Loop** ينتظر تفريغ الـ Call Stack ثم يدفع callback من الـ Queue للتنفيذ.

***

### 4. مثال توضيحي

```javascript
const fs = require('fs');

console.log("1");

fs.readFile("data.txt", "utf8", (err, data) => {
  console.log("2");
});

console.log("3");
```
> 📋 **الإخراج المتوقع:**
>
> 1
>
> 3
>
> 2
>
> ✅ لأن `fs.readFile` عملية غير متزامنة، يتم تنفيذ باقي الكود بينما تنتظر عملية القراءة.

***

### 5. لماذا هذا مفيد؟

* يسمح لـ Node.js بمعالجة آلاف الطلبات بدون الحاجة إلى خيوط متعددة.
* يقلل من استهلاك الموارد.
* يوفّر أداء ممتاز في تطبيقات الشبكة.

> 📌 **لكن:** العمليات الحسابية الثقيلة (CPU-bound) يمكن أن تعيق Event Loop لأنها تستهلك الخيط الوحيد.

***