## 🔑 الوحدة 1: أساسيات المصادقة والتخويل

### 📘 الدرس 2: أفضل ممارسات أمان كلمات المرور

#### 🧠 **ماذا ستتعلم**
* لماذا يجب **أبدًا** عدم تخزين كلمات المرور كنص عادي.
* ما هي عملية التجزئة (Hashing) وكيف تختلف عن التشفير.
* ما هو التمليح (Salting) ولماذا هو ضروري للحماية من الهجمات المتقدمة.
* كيفية استخدام مكتبة `bcrypt` لتجزئة ومقارنة كلمات المرور في Node.js.

---
### 🚫 1. القاعدة الذهبية: لا تخزن كلمات المرور كنص عادي أبدًا
هذه هي القاعدة رقم واحد في أمان التطبيقات. إذا تم اختراق قاعدة بياناتك (ويجب أن تفترض دائمًا أن هذا قد يحدث)، وقمت بتخزين كلمات المرور كنص عادي، فسيتم كشف كلمات مرور جميع المستخدمين على الفور. هذا فشل أمني كارثي يؤدي إلى فقدان ثقة المستخدمين.

> **ببساطة:** تخزين كلمة مرور كنص عادي يشبه كتابة الرقم السري لبطاقتك البنكية على ظهر البطاقة نفسها.

---
### #️⃣ 2. الحل: التجزئة (Hashing)
التجزئة هي عملية **أحادية الاتجاه** تقوم بتحويل سلسلة نصية (كلمة المرور) إلى سلسلة نصية أخرى ذات طول ثابت تسمى **"الهاش" (Hash)**.

* **خصائصها الرئيسية:**
    * **أحادية الاتجاه (One-Way):** من المستحيل عمليًا عكس العملية والحصول على كلمة المرور الأصلية من الهاش.
    * **حتمية (Deterministic):** نفس كلمة المرور ستنتج دائمًا نفس الهاش (باستخدام نفس الخوارزمية).

**كيف نستخدمها لتسجيل الدخول؟**
1.  **عند التسجيل:** يقوم المستخدم بإدخال كلمة المرور. نقوم بتجزئتها ونخزن **الهاش فقط** في قاعدة البيانات.
2.  **عند تسجيل الدخول:** يقوم المستخدم بإدخال كلمة المرور مرة أخرى. نقوم بتجزئة الكلمة التي أدخلها.
3.  نقارن **الهاش الجديد** مع **الهاش المخزن** في قاعدة البيانات. إذا تطابقا، تكون كلمة المرور صحيحة.

---
### 🧂 3. إضافة الملح (Salting): لماذا هي ضرورية؟
**المشكلة مع التجزئة البسيطة:** إذا كان هناك مستخدمان يستخدمان نفس كلمة المرور البسيطة (مثل `password123`)، فسيكون لهما نفس الهاش. يمكن للمهاجمين استخدام جداول ضخمة من الهاشات المحسوبة مسبقًا (تسمى **Rainbow Tables**) للعثور بسرعة على كلمات المرور الشائعة.

**الحل هو التمليح (Salting):**
"الملح" هو سلسلة نصية عشوائية وفريدة يتم إضافتها إلى كلمة المرور **قبل** عملية التجزئة.
* **المستخدم أ:** `password123` + الملح `abc` ← `hash_XYZ`
* **المستخدم ب:** `password123` + الملح `def` ← `hash_PQR`

الآن، على الرغم من أن كلمة المرور الأصلية متطابقة، فإن الهاشات المخزنة مختلفة تمامًا، مما يجعل هجمات Rainbow Tables غير فعالة.

> **ملاحظة:** المكتبات الحديثة مثل `bcrypt` تقوم بإنشاء وإدارة الملح تلقائيًا وتدمجه كجزء من سلسلة الهاش النهائية. لست بحاجة إلى تخزينه بشكل منفصل.

---
### ⚙️ 4. التطبيق العملي: استخدام `bcrypt` في Node.js

#### **الخطوة 1: التثبيت**
```bash
npm install bcrypt
```

#### **الخطوة 2: تجزئة كلمة مرور (عند التسجيل)**
نستخدم دالة `bcrypt.hash`. إنها غير متزامنة.
```javascript
const bcrypt = require('bcrypt');
const saltRounds = 10; // عامل التكلفة، كلما زاد كان أفضل وأبطأ
const plainTextPassword = 'mySuperSecretPassword123';

// تجزئة كلمة المرور
bcrypt.hash(plainTextPassword, saltRounds, (err, hash) => {
  if (err) {
    console.error('Error hashing password:', err);
    return;
  }
  
  // قم بتخزين هذا الـ 'hash' في قاعدة البيانات الخاصة بك
  console.log('Hashed Password:', hash);
  // مثال على الناتج: $2b$10$K/p.d9v.u29/..
});
```

#### **الخطوة 3: مقارنة كلمة مرور (عند تسجيل الدخول)**
نستخدم دالة `bcrypt.compare`. هي أيضًا غير متزامنة وتقارن النص العادي بالهاش المخزن.
```javascript
const loginPassword = 'mySuperSecretPassword123';
const hashFromDatabase = '$2b$10$K/p.d9v.u29/..'; // الهاش الذي قمت بتخزينه

bcrypt.compare(loginPassword, hashFromDatabase, (err, result) => {
  if (err) {
    console.error('Error comparing passwords:', err);
    return;
  }

  if (result) {
    // result === true
    console.log('Password is correct! Login successful.');
  } else {
    // result === false
    console.log('Incorrect password. Login failed.');
  }
});
```
---
