## 🗃️ الوحدة 3: ربط قواعد البيانات مع Node.js

### 📘 الدرس 2: مقدمة في ORMs و Query Builders

#### 🧠 **ماذا ستتعلم**
* ما هو منشئ الاستعلامات (Query Builder).
* ما هو مخطط العلاقات الكائنية (Object-Relational Mapper - ORM).
* إيجابيات وسلبيات استخدام ORM مقارنة بكتابة SQL الخام.
* مثال أساسي على استخدام Sequelize (أحد أشهر ORMs) لإجراء عمليات CRUD.

---
### 🤔 1. المشكلة: تحديات كتابة SQL الخام في التطبيقات
في الدرس السابق، تعلمنا كيفية كتابة استعلامات SQL مباشرة في كود Node.js. هذا يعمل بشكل جيد، ولكنه يواجه بعض التحديات مع نمو التطبيقات:
* **التكرار:** قد تجد نفسك تكتب نفس جمل `SELECT` أو `INSERT` المعقدة في أماكن متعددة.
* **عرضة للخطأ:** خطأ إملائي بسيط في اسم عمود أو جدول لن يتم اكتشافه إلا عند تشغيل الكود.
* **الارتباط الوثيق:** يرتبط منطق تطبيقك بشكل وثيق بهيكل قاعدة البيانات. إذا قمت بإعادة تسمية عمود، يجب عليك البحث عنه وتغييره في كل استعلام في الكود الخاص بك.
* **صعوبة تغيير قاعدة البيانات:** إذا قررت الانتقال من PostgreSQL إلى MySQL، فقد تحتاج إلى إعادة كتابة العديد من الاستعلامات.

---
### 💡 2. الحلول: أدوات بناء الاستعلامات و ORMs

#### **أ. منشئ الاستعلامات (Query Builder) - مثال: Knex.js**
هو مكتبة توفر لك دوال JavaScript يمكنك ربطها معًا لبناء استعلام SQL. أنت لا تزال تفكر بمنطق SQL، لكنك تكتبه بكود JavaScript أكثر أمانًا وقراءة.
**مثال باستخدام Knex.js:**
```javascript
knex('users').where('id', 1).select('username');
// هذا الكود سينتج استعلام SQL: SELECT "username" FROM "users" WHERE "id" = 1;
```

#### **ب. مخطط العلاقات الكائنية (ORM) - مثال: Sequelize, Prisma**
الـ ORM هو مستوى أعلى من التجريد. هو يقوم بـ "تخطيط" أو "ربط" جداول قاعدة البيانات بكائنات أو كلاسات جافاسكريبت (تسمى **Models**). بدلاً من كتابة استعلامات، أنت تتعامل مع هذه الكائنات وتستدعي دوال عليها.
> **ببساطة:** استخدام SQL الخام يشبه التحدث مع ميكانيكي سيارات بلغة تقنية. استخدام ORM يشبه التحدث مع مدير الخدمة: أنت تخبره بما تريد بلغة بسيطة ("أريد جميع المستخدمين")، وهو يقوم بترجمة طلبك إلى التعليمات الفنية للميكانيكي (قاعدة البيانات).

---
### ✨ 3. مثال عملي: استخدام Sequelize

#### **الخطوة 1: التثبيت**
```bash
# تثبيت Sequelize والمشغل الخاص بـ Postgres
npm install sequelize pg pg-hstore
```

#### **الخطوة 2: الاتصال وتعريف الموديل**
```javascript
const { Sequelize, DataTypes } = require('sequelize');

// إعداد الاتصال
const sequelize = new Sequelize('my_first_db', 'postgres', 'your_password', {
  host: 'localhost',
  dialect: 'postgres'
});

// تعريف موديل 'User' الذي يمثل جدول 'users'
const User = sequelize.define('User', {
  username: {
    type: DataTypes.STRING,
    allowNull: false
  },
  email: {
    type: DataTypes.STRING,
    allowNull: false,
    unique: true
  }
}, {
  tableName: 'users', // نحدد اسم الجدول بشكل صريح
  timestamps: false // نوقف إضافة أعمدة createdAt/updatedAt التلقائية
});
```

#### **الخطوة 3: إجراء عمليات CRUD**
الآن يمكننا التفاعل مع قاعدة البيانات باستخدام دوال بسيطة بدلاً من SQL.
```javascript
// لإنشاء مستخدم (INSERT)
const newUser = await User.create({ username: 'layla', email: 'layla@example.com' });

// لقراءة جميع المستخدمين (SELECT *)
const users = await User.findAll();

// لقراءة مستخدم واحد بمعرفه (SELECT ... WHERE id = ...)
const user = await User.findByPk(1);

// لتحديث مستخدم (UPDATE)
await User.update({ email: 'new.email@example.com' }, {
  where: { id: 1 }
});

// لحذف مستخدم (DELETE)
await User.destroy({
  where: { id: 1 }
});
```
لاحظ كيف أننا لم نكتب أي كلمة SQL! الـ ORM قام بكل العمل في الخلفية.

---
### ⚖️ 4. المقايضة: ORM مقابل SQL الخام

| إيجابيات الـ ORM ✅ | سلبيات الـ ORM ❌ |
| :--- | :--- |
| **تطوير أسرع:** كتابة كود أقل لإنجاز نفس المهام. | **أداء أقل:** قد ينتج استعلامات SQL أقل كفاءة من تلك المكتوبة يدويًا، خاصة في الحالات المعقدة. |
| **أقل عرضة للأخطاء:** يقلل من الأخطاء الإملائية ويمنع حقن SQL. | **طبقة من التعقيد:** يضيف طبقة تجريد إضافية قد تكون صعبة التصحيح أحيانًا. |
| **محايد لقاعدة البيانات:** يسهل الانتقال من PostgreSQL إلى MySQL مثلاً. | **صعوبة في الاستعلامات المعقدة جدًا:** قد تجد نفسك مضطرًا لكتابة SQL خام على أي حال. |
| **موجه للكائنات (Object-Oriented):** يناسب طريقة تفكير المطورين. | |

---
