## 🗃️ الوحدة 2: استعلامات SQL المتقدمة وتصميم قواعد البيانات

### 📘 الدرس 3: تطبيع قواعد البيانات (Database Normalization)

#### 🧠 **ماذا ستتعلم**
* ما هو تطبيع قواعد البيانات ولماذا هو مهم جدًا.
* المشاكل التي يسببها تكرار البيانات (Data Redundancy).
* مفهوم الشكل الطبيعي الأول (1NF).
* مفهوم الشكل الطبيعي الثاني (2NF).
* مفهوم الشكل الطبيعي الثالث (3NF).

---
### 🤔 1. ما هو التطبيع ولماذا نحتاجه؟
التطبيع (Normalization) هو عملية تنظيم الأعمدة والجداول في قاعدة بيانات علائقية لتقليل **تكرار البيانات** إلى الحد الأدنى وتحسين **سلامة البيانات (Data Integrity)**.

**لماذا هو مهم؟** لنفترض أن لدينا جدولاً واحداً لتخزين معلومات الطلبات، ويحتوي على اسم العميل وعنوانه مع كل طلب.
* **مشكلة التكرار:** إذا قام عميل واحد بـ 100 طلب، فسيتم تخزين اسمه وعنوانه 100 مرة! هذا يهدر مساحة التخزين.
* **مشكلة سلامة البيانات:** إذا انتقل هذا العميل إلى عنوان جديد، فسنحتاج إلى تحديث 100 صف! إذا نسينا تحديث صف واحد، فستصبح بياناتنا غير متسقة وغير موثوقة.

التطبيع يحل هذه المشاكل عن طريق تقسيم البيانات إلى جداول متعددة ومترابطة.

---
### 1️⃣ 2. الشكل الطبيعي الأول (1NF)
**القاعدة:** يجب أن يحتوي كل حقل (خلية) في الجدول على **قيمة واحدة فقط (atomic value)**، ويجب ألا تكون هناك مجموعات متكررة من الأعمدة.

* **مثال سيئ (غير مطابق لـ 1NF):**
| order_id | customer_name | books |
| :--- | :--- | :--- |
| 101 | Ahmed | 'The Hobbit, 1984' |

المشكلة هنا هي أن عمود `books` يحتوي على قيم متعددة.

* **الحل (مطابق لـ 1NF):**
نقسمها إلى صفوف منفصلة، وعادةً ما يتطلب ذلك إنشاء جدول جديد.
**جدول `Orders`**
| order_id | customer_name |
| :--- | :--- |
| 101 | Ahmed |
**جدول `Order_Items`**
| item_id | order_id | book_title |
| :--- | :--- | :--- |
| 1 | 101 | The Hobbit |
| 2 | 101 | 1984 |

---
### 2️⃣ 3. الشكل الطبيعي الثاني (2NF)
**القاعدة:** يجب أن يكون الجدول في 1NF أولاً، ويجب أن يعتمد كل عمود غير مفتاحي بشكل **كامل** على المفتاح الأساسي بأكمله (وليس على جزء منه فقط). (هذه القاعدة مهمة بشكل خاص عندما يكون لديك مفتاح أساسي مركب).

* **مثال سيئ (غير مطابق لـ 2NF):**
لنفترض أن جدول `Order_Items` لديه مفتاح أساسي مركب من `(order_id, book_title)` ويحتوي على سعر الكتاب.
| order_id | book_title | book_price |
| :--- | :--- | :--- |
| 101 | The Hobbit | 15.00 |
| 102 | The Hobbit | 15.00 |
هنا، `book_price` يعتمد فقط على `book_title`، وليس على `order_id`. هذا يسمى "اعتمادية جزئية" ويسبب تكرارًا (سعر "The Hobbit" مكرر).

* **الحل (مطابق لـ 2NF):**
نفصل البيانات غير المعتمدة بشكل كامل في جدول خاص بها.
**جدول `Books`**
| book_id | title | price |
| :--- | :--- | :--- |
| 1 | The Hobbit| 15.00 |
**جدول `Order_Items`**
| order_id | book_id |
| :--- | :--- |
| 101 | 1 |
| 102 | 1 |

---
### 3️⃣ 4. الشكل الطبيعي الثالث (3NF)
**القاعدة:** يجب أن يكون الجدول في 2NF أولاً، ويجب ألا يحتوي على **اعتماديات متعدية (transitive dependencies)**. هذا يعني أن الأعمدة غير المفتاحية يجب أن تعتمد على المفتاح الأساسي **فقط**، وليس على أعمدة غير مفتاحية أخرى.

* **مثال سيئ (غير مطابق لـ 3NF):**
لنفترض أن لدينا جدول `Orders` بالشكل التالي:
| order_id | customer_id | customer_name |
| :--- | :--- | :--- |
| 101 | 1 | Ahmed |
| 102 | 1 | Ahmed |
هنا، `customer_name` يعتمد على `customer_id`، والذي بدوره يعتمد على `order_id`. هذا اعتماد متعدٍ. إذا تغير اسم العميل، يجب علينا تحديثه في كل طلب قام به.

* **الحل (مطابق لـ 3NF):**
نفصل بيانات العميل في جدول خاص بها.
**جدول `Customers`**
| customer_id | name |
| :--- | :--- |
| 1 | Ahmed |
**جدول `Orders`**
| order_id | customer_id |
| :--- | :--- |
| 101 | 1 |
| 102 | 1 |

هذا هو التصميم السليم الذي يمنع التكرار ويحافظ على سلامة البيانات.

---
