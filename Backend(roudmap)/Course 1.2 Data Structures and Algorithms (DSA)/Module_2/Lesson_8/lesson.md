## 🧠 الوحدة 2: الخوارزميات الأساسية (Core Algorithms)

### 📘 الدرس 8: خوارزمية الفرز بالدمج (Merge Sort)

#### 🧠 **ماذا ستتعلم**
* مفهوم خوارزمية الفرز بالدمج ومبدأ "فرّق تسد".
* كيفية عمل الخوارزمية بتقسيم المصفوفة ودمجها.
* كتابة دالة `mergeSort` ودالة الدمج المساعدة `merge` بلغة جافاسكريبت.
* تحليل تعقيد الخوارزمية الزمني والمكاني.

---
### 📝 1. ما هو الفرز بالدمج؟
الفرز بالدمج هو خوارزمية فرز عالية الكفاءة تعتمد على مبدأ **"فرّق تسد" (Divide and Conquer)**. على عكس الخوارزميات البسيطة التي رأيناها ($O(n^2)$)، يقدم الفرز بالدمج أداءً أفضل بكثير مع القوائم الكبيرة.

---
### 👣 2. كيف تعمل خوارزمية الفرز بالدمج؟
تعمل الخوارزمية على ثلاث خطوات رئيسية:
1.  **فرّق (Divide):** تقوم بتقسيم المصفوفة بشكل متكرر إلى نصفين حتى تصل إلى مصفوفات تحتوي على عنصر واحد فقط (أو فارغة). المصفوفة التي تحتوي على عنصر واحد تعتبر مرتبة بطبيعتها.
2.  **تسد (Conquer):** بعد التقسيم، تبدأ في دمج هذه المصفوفات الصغيرة المرتبة معًا لإنشاء مصفوفات أكبر ومرتبة.
3.  **ادمج (Combine):** تستمر عملية الدمج حتى تعود إلى مصفوفة واحدة كاملة ومرتبة.

**مثال بصري:**
`[8, 3, 5, 1]` -> `[8, 3]` | `[5, 1]` -> `[8]` | `[3]` | `[5]` | `[1]` -> `[3, 8]` | `[1, 5]` -> `[1, 3, 5, 8]`

---
### ⚙️ 3. وظيفة الدمج المساعدة (The `merge` Helper)
الجزء الأهم في الخوارزمية هو وظيفة الدمج التي تأخذ مصفوفتين **مرتبتين** وتدمجهما في مصفوفة واحدة جديدة ومرتبة.

```javascript
function merge(leftArr, rightArr) {
  let sortedArr = [];
  let leftIndex = 0;
  let rightIndex = 0;

  // قارن بين عناصر المصفوفتين وأضف الأصغر إلى المصفوفة الجديدة
  while (leftIndex < leftArr.length && rightIndex < rightArr.length) {
    if (leftArr[leftIndex] < rightArr[rightIndex]) {
      sortedArr.push(leftArr[leftIndex]);
      leftIndex++;
    } else {
      sortedArr.push(rightArr[rightIndex]);
      rightIndex++;
    }
  }

  // أضف أي عناصر متبقية من المصفوفتين
  return sortedArr.concat(leftArr.slice(leftIndex)).concat(rightArr.slice(rightIndex));
}
```

---
### 📝 4. مثال على خوارزمية الفرز بالدمج الكاملة:

```javascript
function mergeSort(arr) {
  // الحالة الأساسية (Base Case): إذا كانت المصفوفة تحتوي على عنصر واحد أو أقل، فهي مرتبة
  if (arr.length <= 1) {
    return arr;
  }

  // 1. فرّق: جد منتصف المصفوفة وقسمها
  const middle = Math.floor(arr.length / 2);
  const leftHalf = arr.slice(0, middle);
  const rightHalf = arr.slice(middle);

  // 2. تسد: استدعِ الدالة بشكل متكرر على كل نصف
  const sortedLeft = mergeSort(leftHalf);
  const sortedRight = mergeSort(rightHalf);

  // 3. ادمج: ادمج النصفين المرتبين
  return merge(sortedLeft, sortedRight);
}
```

---
### 📈 5. تحليل التعقيد
* **تعقيد الوقت (Time Complexity):** **$O(n \log n)$** في جميع الحالات (الأفضل، الأسوأ، والمتوسط).
    * `log n`: يمثل عدد مرات تقسيم المصفوفة.
    * `n`: يمثل عدد المقارنات في كل مستوى من مستويات الدمج.
* **تعقيد المساحة (Space Complexity):** **$O(n)$** - لأنها تحتاج إلى إنشاء مصفوفات مؤقتة لعملية الدمج، فهي ليست خوارزمية "in-place".

---
### 💡 6. مميزات وعيوب الفرز بالدمج

| المميزات | العيوب |
| :--- | :--- |
| أداء فعال ومستقر ($O(n \log n)$). | ليست "in-place"، تتطلب ذاكرة إضافية ($O(n)$). |
| مناسبة جدًا للقوائم الكبيرة. | قد تكون أبطأ قليلاً من الخوارزميات الأخرى للقوائم الصغيرة جدًا. |
| خوارزمية مستقرة (تحافظ على الترتيب النسبي للعناصر المتساوية). | |

---
### 🛠️ جرب بنفسك
* جرّب كتابة دالتي `merge` و `mergeSort` بنفسك.
* خذ مصفوفة صغيرة مثل `[38, 27, 43, 3, 9, 82, 10]` وتتبع خطوات التقسيم والدمج على الورق.

---