## 🧠 الوحدة 2: الخوارزميات الأساسية (Core Algorithms)

### 📘 الدرس 9: خوارزمية الفرز السريع (Quick Sort)

#### 🧠 **ماذا ستتعلم**
* مفهوم خوارزمية الفرز السريع ومبدأ "فرّق تسد".
* دور العنصر المحوري (Pivot) في الخوارزمية.
* كيفية عمل وظيفة التقسيم (`partition`).
* كتابة دالة `quickSort` بلغة جافاسكريبت.
* تحليل تعقيد الخوارزمية (الأفضل، المتوسط، والأسوأ).

---
### 📝 1. ما هو الفرز السريع؟
الفرز السريع هو خوارزمية فرز عالية الكفاءة تعتمد أيضًا على مبدأ **"فرّق تسد" (Divide and Conquer)**. لكن على عكس الفرز بالدمج، تتم معظم العمليات أثناء مرحلة **التقسيم** وليس الدمج. غالبًا ما تكون أسرع في الممارسة العملية من الخوارزميات الأخرى ذات نفس التعقيد الزمني.

---
### 👣 2. كيف تعمل خوارزمية الفرز السريع؟
1.  **اختر محورًا (Choose a Pivot):** يتم اختيار عنصر من المصفوفة ليصبح "المحور". يمكن أن يكون هذا العنصر الأول، الأخير، أو عنصرًا عشوائيًا.
2.  **قسّم (Partition):** يتم إعادة ترتيب المصفوفة بحيث توضع جميع العناصر الأصغر من المحور على يساره، وجميع العناصر الأكبر منه على يمينه. بعد هذه الخطوة، يكون المحور في مكانه النهائي الصحيح.
3.  **كرر (Recurse):** يتم تطبيق الخوارزمية بشكل عودي (recursively) على المصفوفتين الفرعيتين (اليسرى واليمنى) اللتين تم إنشاؤهما في خطوة التقسيم.

---
### ⚙️ 3. وظيفة التقسيم (The `partition` Helper)
هذه هي الوظيفة الأساسية في الفرز السريع. مهمتها هي أخذ عنصر المحور ووضعه في موقعه الصحيح في المصفوفة المرتبة، ووضع جميع العناصر الأصغر قبله والأكبر بعده.

```javascript
// وظيفة مساعدة لتبديل عنصرين
function swap(arr, i, j) {
  [arr[i], arr[j]] = [arr[j], arr[i]];
}

// وظيفة التقسيم (باستخدام نظام Lomuto Partition Scheme)
function partition(arr, low, high) {
  // اختيار العنصر الأخير كمحور
  let pivot = arr[high];
  let i = low - 1;

  for (let j = low; j < high; j++) {
    if (arr[j] < pivot) {
      i++;
      swap(arr, i, j);
    }
  }
  
  // ضع المحور في مكانه الصحيح
  swap(arr, i + 1, high);
  return i + 1; // أرجع مؤشر المحور
}
```

---
### 📝 4. مثال على خوارزمية الفرز السريع الكاملة:
```javascript
function quickSort(arr, low = 0, high = arr.length - 1) {
  if (low < high) {
    // pi هو مؤشر التقسيم، arr[pi] هو الآن في المكان الصحيح
    let pi = partition(arr, low, high);

    // فرز العناصر قبل وبعد التقسيم بشكل منفصل
    quickSort(arr, low, pi - 1);
    quickSort(arr, pi + 1, high);
  }
  return arr;
}
```

---
### 📈 5. تحليل التعقيد
* **أفضل حالة ومتوسط الحالة (Best & Average Case):** **$O(n \log n)$**
    * يحدث هذا عندما يقسم المحور المصفوفة إلى نصفين متساويين تقريبًا في كل مرة.
* **أسوأ حالة (Worst Case):** **$O(n^2)$**
    * يحدث هذا عند اختيار أسوأ محور ممكن بشكل متكرر (على سبيل المثال، اختيار أصغر أو أكبر عنصر في مصفوفة مرتبة بالفعل)، مما يؤدي إلى تقسيم غير متوازن تمامًا.
* **تعقيد المساحة (Space Complexity):** **$O(\log n)$**
    * بسبب مساحة مكدس الاستدعاءات العودية (recursion call stack). تعتبر خوارزمية "in-place" لأنها لا تحتاج لمصفوفات إضافية مثل الفرز بالدمج.

---
### 💡 6. مميزات وعيوب الفرز السريع

| المميزات | العيوب |
| :--- | :--- |
| سريعة جدًا في المتوسط، وغالبًا ما تكون أسرع من الخوارزميات الأخرى. | أسوأ حالة لها هي $O(n^2)$، وهو أداء سيئ. |
| تعمل في مكانها (In-place)، مما يقلل من استهلاك الذاكرة. | ليست خوارزمية مستقرة (قد يتغير الترتيب النسبي للعناصر المتساوية). |
| شائعة الاستخدام في العديد من المكتبات والأنظمة. | يمكن أن تكون معقدة بعض الشيء في التنفيذ الصحيح. |

---
### 🛠️ جرب بنفسك
* جرّب كتابة دالتي `partition` و `quickSort` بنفسك.
* خذ مصفوفة صغيرة وتتبع كيف يتم اختيار المحور وإعادة ترتيب العناصر حوله في كل استدعاء عودي.

---